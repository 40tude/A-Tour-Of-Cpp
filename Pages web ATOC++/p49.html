A tour of C++ – Exemple de la page 49

Il s'agit d'un des codes d'exemple du livre écrit par Bjarne Stroustrup et qui est disponible <a href="http://www.amazon.fr/Tour-C-Bjarne-Stroustrup/dp/0321958314/ref=sr_1_1?ie=UTF8&amp;qid=1416699327&amp;sr=8-1&amp;keywords=a+tour+of+c%2B%2B" target="_blank">ici</a>. Le contenu de ce livre correspond au début du livre The C++ Programming Language qu'on trouve <a href="http://www.amazon.fr/The-Programming-Language-Bjarne-Stroustrup/dp/0321563840/ref=pd_sim_eb_3?ie=UTF8&amp;refRID=0CR047TTJV1HA6CVA9XA" target="_blank">ici</a>.

Pour chaque exemple, j'ai essayé de faire en sorte que le code se compile, soit complètement autonome et tienne dans un seul source.
J'ai aussi tenté d'avoir des sorties à l'écran afin qu'on se rende compte un peu mieux de se qui se passe vraiment.
Oui, oui bien sûr, y a des cas où il faut aller vérifier avec un débogueur.
En tout cas l'objectif est de pouvoir avoir un code fonctionnel qu'on puisse compiler et dans lequel on puisse naviguer.
J'ai tenté de coller au maximum à l'exemple du bouquin. A part peut être un ou deux cas, j'ai dû renommer certains variables.

J'ai surtout travaillé avec <a href="http://www.visualstudio.com/products/visual-studio-community-vs" target="_blank">Visual Studio Community 2013</a>.
Ceci dit les exemples tournent dans<a href="http://ideone.com/" target="_blank"> Ideone.com</a> ou la <a href="http://webcompiler.cloudapp.net/" target="_blank">version en ligne</a> du compilateur C++ de Microsoft.
Dans certains, j'ai été amené à aller y faire des tests.
Dans certains cas j'ai aussi fait aussi des tests avec le compilateur clang de mon Mac.
Pour utiliser le code, il suffit de faire un copier coller et zou c'est parti.
Pour les explications, bien sûr vaut mieux se référer aux livres de l'auteur.

<h3>Notes spécifiques à cet exemple</h3>
Le mieux ici c'est de mettre un point d'arrêt sur la ligne 116 (première ligne de la fonction Test()) et de voir pas à pas comment cela se passe.

<pre class="brush: cpp; gutter: true; first-line: 1">
#ifdef _MSC_VER
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>
#endif // _MSC_VER

#include <iostream> 

using namespace std;

// ----------------------------------------------------------------------------
class Vector {
private:
	double* elem;                                                                 // elem points to an array of sz doubles
	int sz;

public:
	Vector() : elem{ nullptr }, sz{ 0 } {}
	explicit Vector(int s) :elem{ new double[s] }, sz{ s } {                      // constructor: establish invariant, acquire resources
                                                                                // explicit => no implicit conversion from int to Vector. Avoid Vector v2 = 7; allow Vector v2(7);
                                                                                // advise : use explicit for constructors that take a single argument unless there is a good reason not to
		for (int i = 0; i != s; ++i) {												                      // initialize elements
			elem[i] = 0;
		}
	}

	~Vector() { delete[] elem; }                                                  // destructor: release resources
	Vector(const Vector& a);                                                      // copy constructor
	Vector& operator=(const Vector& a);                                           // copy assignment
	Vector(Vector&& a);                                                           // move constructor
	Vector& operator=(Vector&& a);                                                // move assignment

	//const double& operator[](int i) const { return elem[i]; };                  // read only operator since returned value is const
	double& operator[](int i) const { return elem[i]; };
	int size() const {return sz;};
};

// ----------------------------------------------------------------------------
// copy constructor
Vector::Vector(const Vector& a) : elem{ new double[a.sz] }, sz{ a.sz } {          // allocate space for elements 

	for (int i = 0; i != sz; ++i)                                                   // copy elements
		elem[i] = a.elem[i];
}

// ----------------------------------------------------------------------------
// copy assignment
Vector& Vector::operator=(const Vector& a) {

	double* p = new double[a.sz];
	for (int i = 0; i != a.sz; ++i)
		p[i] = a.elem[i];
	delete[] elem;                                                                // delete old elements
	elem = p;
	sz = a.sz;
	return *this;
}

// ----------------------------------------------------------------------------
// A move constructor does not take a const argument
Vector::Vector(Vector&& a) : elem{ a.elem }, sz{ a.sz } {                       // "grab the elements" from a

	a.elem = nullptr;                                                             // now a has no elements
	a.sz = 0;
}

// ----------------------------------------------------------------------------
// move assignement
Vector& Vector::operator=(Vector&& a) {

	if (this != &a) {
		delete[] elem;
		sz = 0;
		elem = a.elem;
		sz = a.sz;
		a.elem = nullptr;                                                           // now a has no elements
		a.sz = 0;
	}
	return *this;
}

// ----------------------------------------------------------------------------
Vector operator+(const Vector& a, const Vector& b) {
	if (a.size() != b.size())
		//throw Vector_size_mismatch {};
		throw out_of_range("operator+");
	
  Vector res(a.size());
	for (int i = 0; i != a.size(); ++i)
		res[i] = a[i] + b[i];
	return res;
}

// ----------------------------------------------------------------------------
void g(const Vector& x, const Vector& y, const Vector& z) {

	Vector r;
	// ...
	r = x + y + z;
	// ...
}

// ----------------------------------------------------------------------------
Vector f() {
	Vector x(1000);
	Vector y(1000);
	Vector z(1000);

	z = x;                                                                        // we get a copy
	y = std::move(x);                                                             // we get a move
	return z;                                                                     // we get a move
};

// ----------------------------------------------------------------------------
void Test(void) {

	Vector myV = f();

	Vector x(1000);
	Vector y(1000);
	Vector z(1000);
	g(x, y, z);

}

// ----------------------------------------------------------------------------
int main() {

#ifdef _MSC_VER
  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif // _MSC_VER

  Test();

#ifdef _MSC_VER
  //_CrtMemDumpAllObjectsSince(NULL);                                             // Begins the dump from the start of program execution
  _CrtDumpMemoryLeaks();
#endif // _MSC_VER

  cout << "Press ENTER to quit : ";
  cin.ignore((numeric_limits<streamsize>::max)(), '\n');
}
</pre>